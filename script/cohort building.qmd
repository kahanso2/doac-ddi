---
title: "doac-ddi"
author: "Kent Hanson"
format: html
editor: visual
---

# About

The goal of this analysis is to explore DDI in CVD using the SCCS as a high-throughput screening technique

# Packages

```{r}
#| label: load-packages/functions
#| include: false

pacman::p_load(tidyverse, arrow, duckdb, tictoc, haven, reshape2, lubridate, SCCS, janitor, fs, here, AdhereR, remotes, lme4, gnm, survival, grid, forestploter, duckplyr, xlsx, data.table, progress)

# Call functions
source(here("codes/functions.R"))

```

# Specification Station

```{r}
#Comment out - saved in functions.R
# #ICD Codes (Bykov 2020)
# outcome <- c(72888, 72889, 72887, 7289, 7291, 72881, 7913, 7104, 35989, 3599, "M6282", "M6289", "M6281", "M629", "M791", "M609", "M601", "M608", "R821", "M332", "G7289", "G729", "G720")
# 
# #Object vector
# object <- c("Simvastatin", "Atorvastatin", "Lovastatin", "Pitavastatin", "Rosuvastatin", "Fluvastatin", "Pravastatin")
# 
# #Precipitant(s) vector
# precipitant <- c("Fluconazole", "Lisinopril", "Gemfibrozil", "Clarithromycin", "Levothyroxin", "Metformin")
# 
# #cont_enroll_req day requirement
# cont_enroll_req <- 90
# 
# #New user requirement
# new_user_req <- '2009-04-01'
# 
# #Object grace period
# obj_grace <- 14
# 
# #Precipitant grace period
# precip_grace <- 1

```

# Data

## Inpatient Data

```{r}
#| label: Inpatient Data

#Need to merge with inpatient services (S) to get revenue code
redbook <- arrow::read_parquet("//pharm-psop/Truven Data/Truven Data R/redbook.parquet")

# #Apixaban NDC codes
# apixaban_ndc <- redbook |> 
#   filter(NDCNUM %in% c("82982005430", "82804008530", "71610081183", "71610066280", "71610066218", "71610066209", "70518186100", "63629843202", "63629843201", "63629774704", "63629774703", "63629774702", "63629774701", "55154061308", "55154061300", "55154061208", "55154061200", "50090645400", "50090645100", "50090143700", "00003376474", "00003089491", "00003089470", "00003089431", "00003089421", "00003089391", "00003089331", "00003089321", "14445015060", "14445015018", "14445015010", "14445015005", "14445014960", "14445014918", "14445014914", "14445014905", "14445014910")) 
# 
# apixaban_ndc <- apixaban_ndc$NDCNUM
# 
# 
# rivaroxaban_ndc <- redbook |> 
#   filter(NDCNUM %in% c("50090362500", "50090362501", "50090446900", "50458057501", "50458057710", "50458057714", "50458057718", "50458057760", "50458057807", "50458057810", "50458057830", "50458057890", "50458057907", "50458057910", "50458057930", "50458057989", "50458057990", "50458058007", "50458058010", "50458058030", "50458058090", "50458058451", "50458058452", "55154142200", "55154142308", "55154142408", "71610069042"))
# 
# rivaroxaban_ndc <- rivaroxaban_ndc$NDCNUM
# 
# dabigatran_ndc <- redbook |> 
#   filter(NDCNUM %in% c("72205020260", "72205020460", "31722062160", "31722062260", "60505434702", "60505434706", "60505434806", "60505434906", "60687074421", "60687075232", "62332063406", "62332063460", "62332063606", "62332063660", "67877047460", "67877047560", "72865027260", "72865027360", "00597042578", "00597043018", "00597043596", "00597044053", "00597044587", "00597045016", "00597010854", "00597010860", "00597035509", "00597035556", "00597036055", "00597036082", "50090448000", "63629824201"))
# 
# dabigatran_ndc <- dabigatran_ndc$NDCNUM
# 
# #Better to use GENNME in case redbook has some uncaptured here all FDA identified NDC have correct GENNME. 

mdcri_2009_2021 <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/i") 
mdcrs_2009_2021 <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/s")
```

# Identify patients who have the outcome of interest
```{r}
#Collect enrolid for patients with hosp for bleed from 2009-2021 (criteria outlined by Leonard et al)

#Filter and collect ccaes cases with transfusion REVCODE 
ccaes_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/ccae/s") |> 
  select(c(ENROLID, YEAR, ADMDATE, DISDATE, REVCODE)) |> 
  to_duckdb() |> 
  filter(REVCODE %in% c("0390", "0391") & !is.na(ENROLID)) |> 
  distinct(ENROLID, .keep_all = TRUE) |> 
  collect() #1304548 obs

#Collect the inpatient (time: 9 minutes for full)
ccaei_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/ccae/i", unify_schemas = TRUE) |> #24224052 obs
  select(c(ENROLID, YEAR, ADMDATE, AGE, DAYS, DISDATE, DXVER, PDX, DX1:DX15, PROC1:PROC15)) |> 
  to_duckdb() |> 
  collect() 

#Merge ccaei with ccaes to get REVCODE
ccaei_2009_2021_bleed_merge <- ccaei_2009_2021_bleed |> 
  left_join(ccaes_2009_2021_bleed, by = c("ENROLID", "YEAR", "ADMDATE", "DISDATE")) |> 
  filter(!is.na(ENROLID)) |>
  replace_na(list(DXVER = "9")) |> 
  filter(DXVER != "") |> #removes blanks that probably indicate ambulance services (at this did for 4082398001)
  mutate(DXVER = as.numeric(DXVER))

#Identify IDs with event in ccae using criteria outlined by Leonard et al (time: 14 min)
ccae_bleed_outcome_2009_2021 <- ccaei_2009_2021_bleed_merge |> #24168165 obs
  #filter(YEAR == 2021) |>  #test to make sure working on small dataset
  #filter(ENROLID == 4082398001) |> 
  mutate(
    bleed_code = if_else(
      is.na(DXVER) | DXVER == 9, #think can remove is.na(DXVER but not checking now)
      if_any(PDX, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
        (if_any(PDX, ~str_detect(.x, {{all_gib_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
            !is.na(REVCODE))) | 
      (if_any(PDX, ~str_detect(.x, {{all_unspec_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})))) |
      (if_any(PDX, ~ gu_icd9_possible %in% .x)  &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}}))) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_comb_sec}})))),
      if_else(
        DXVER == 0, 
        if_any(PDX, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
          (if_any(PDX, ~str_detect(.x, {{all_gib_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
                !is.na(REVCODE))) | 
          (if_any(PDX, ~str_detect(.x, {{all_unspec_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})))),
        NA
      )
    )
  ) |>
  group_by(ENROLID) |> 
  mutate(bleed_ever = as.integer(any(bleed_code))) |> 
  filter(bleed_ever == 1) |> #797760 - now 796266 - maybe old ICD codes were errant?
  ungroup() #We have to keep this in because it pulls in people who have had a bleed event, but also all other inpt admissions. Can filter by bleed_code later


ccae_bleed_outcome2 <- ccae_bleed_outcome_2009_2021 |> 
  mutate(
    trauma_code = if_else(
      DXVER == 9,
      if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd9}})) |
        if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})), 
      if_else(
        DXVER == 0,
        if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd10}})) |
          if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})),
        NA
      )
    )
  ) #796266

inpatient_trauma <- ccae_bleed_outcome2 |> 
  select(ENROLID, ADMDATE, DXVER, trauma_code) |> 
  filter(trauma_code == TRUE) |> 
  mutate(source = "inpatient")


#Above collects patients who had an inpatient bleed event. Need to pull them into outpatient dataset to search for trauma
outcome_enrolid <- unique(ccae_bleed_outcome_2009_2021$ENROLID)

ccaeo_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/ccae/o", unify_schemas = TRUE) |> 
  select(ENROLID, SVCDATE, DXVER, DX1, DX2, DX3, DX4, PROC1) |> 
  to_duckdb() |> 
  filter(ENROLID %in% outcome_enrolid) |> 
  collect() #96698718 obs

ccaeo_2009_2021_bleed2 <- ccaeo_2009_2021_bleed |> 
  replace_na(list(DXVER = "9")) |> 
  filter(DXVER != "") |> #removes blanks that probably indicate ambulance services (at this did for 4082398001)
  mutate(DXVER = as.numeric(DXVER)) |> 
  mutate(trauma_code = if_else(
      DXVER == 9,
      if_any(DX1:DX4, ~str_detect(.x, {{trauma_check_icd9}})) |
        if_any(PROC1, ~str_detect(.x, {{trauma_hcpcs_all}})), 
      if_else(
        DXVER == 0,
        if_any(DX1:DX4, ~str_detect(.x, {{trauma_check_icd10}})) |
          if_any(PROC1, ~str_detect(.x, {{trauma_hcpcs_all}})),
        NA
      )
    )
  )

# Outpatient trauma codes
outpatient_trauma <- ccaeo_2009_2021_bleed2 |> 
  select(ENROLID, SVCDATE, DXVER, trauma_code) |> 
  filter(trauma_code == TRUE) |> 
  mutate(ADMDATE = SVCDATE, source = "outpatient") |> 
  select(-SVCDATE)

# Combine trauma codes
all_trauma_codes <- bind_rows(inpatient_trauma, outpatient_trauma) |> 
  distinct() |> 
  arrange(ENROLID, ADMDATE)


#Join trauma codes with main dataset
ccae_bleed_outcome_merged <- ccae_bleed_outcome_2009_2021 |> 
  left_join(all_trauma_codes, by = "ENROLID") |> 
   mutate(
    within_window = (ADMDATE.x - 1 <= ADMDATE.y & ADMDATE.y <= ADMDATE.x + 1)
  ) |> 
  filter(within_window) |> 
  distinct(ENROLID, ADMDATE.x) |> 
  mutate(exclusion_event = 1)

ccae_bleed_outcome_no_trauma <- ccae_bleed_outcome_2009_2021 |> 
  left_join(ccae_bleed_outcome_merged, by = c("ENROLID", "ADMDATE" = "ADMDATE.x")) |> 
  filter(bleed_code == TRUE) |> 
  filter(is.na(exclusion_event)) #38587


#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
ccae_bleed_outcome_no_trauma |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ccae_bleed_outcome_no_trauma.parquet")

#Open dataset
ccae_bleed_outcome_no_trauma <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ccae_bleed_outcome_no_trauma.parquet")


##MDCR - 8 min to run entire mdcr inpt
#Filter and collect ccaes cases with transfusion REVCODE 
mdcrs_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/s") |> 
  select(c(ENROLID, YEAR, ADMDATE, DISDATE, REVCODE)) |> 
  to_duckdb() |> 
  filter(REVCODE %in% c("0390", "0391") & !is.na(ENROLID)) |> 
  distinct(ENROLID, .keep_all = TRUE) |> 
  collect() #1304548 obs

#Collect the inpatient (time: 9 minutes for full)
mdcri_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/i", unify_schemas = TRUE) |> #24224052 obs
  select(c(ENROLID, YEAR, ADMDATE, AGE, DAYS, DISDATE, DXVER, PDX, DX1:DX15, PROC1:PROC15)) |> 
  to_duckdb() |> 
  collect() 

#Merge mdcri with mdcrs to get REVCODE
mdcri_2009_2021_bleed_merge <- mdcri_2009_2021_bleed |> 
  left_join(mdcrs_2009_2021_bleed, by = c("ENROLID", "YEAR", "ADMDATE", "DISDATE")) |> 
  filter(!is.na(ENROLID)) |>
  replace_na(list(DXVER = "9")) |> 
  filter(DXVER != "") |> #removes blanks that probably indicate ambulance services (at this did for 4082398001)
  mutate(DXVER = as.numeric(DXVER))

#Identify IDs with event in mdcr using criteria outlined by Leonard et al (time: 14 min)
mdcr_bleed_outcome_2009_2021 <- mdcri_2009_2021_bleed_merge |> #24168165 obs
  #filter(YEAR == 2021) |>  #test to make sure working on small dataset
  #filter(ENROLID == 4082398001) |> 
  mutate(
    bleed_code = if_else(
      is.na(DXVER) | DXVER == 9, #think can remove is.na(DXVER but not checking now)
      if_any(PDX, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
        (if_any(PDX, ~str_detect(.x, {{all_gib_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
            !is.na(REVCODE))) | 
      (if_any(PDX, ~str_detect(.x, {{all_unspec_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})))) |
      (if_any(PDX, ~ gu_icd9_possible %in% .x)  &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}}))) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_comb_sec}})))),
      if_else(
        DXVER == 0, 
        if_any(PDX, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
          (if_any(PDX, ~str_detect(.x, {{all_gib_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
                !is.na(REVCODE))) | 
          (if_any(PDX, ~str_detect(.x, {{all_unspec_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})))),
        NA
      )
    )
  ) |>
  group_by(ENROLID) |> 
  mutate(bleed_ever = as.integer(any(bleed_code))) |> 
  filter(bleed_ever == 1) |> #797760 - now 796266 - maybe old ICD codes were errant?
  ungroup() #We have to keep this in because it pulls in people who have had a bleed event, but also all other inpt admissions. Can filter by bleed_code later


mdcr_bleed_outcome2 <- mdcr_bleed_outcome_2009_2021 |> 
  mutate(
    trauma_code = if_else(
      DXVER == 9,
      if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd9}})) |
        if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})), 
      if_else(
        DXVER == 0,
        if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd10}})) |
          if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})),
        NA
      )
    )
  ) #796266

mdcr_inpatient_trauma <- mdcr_bleed_outcome2 |> 
  select(ENROLID, ADMDATE, DXVER, trauma_code) |> 
  filter(trauma_code == TRUE) |> 
  mutate(source = "inpatient")


#Above collects patients who had an inpatient bleed event. Need to pull them into outpatient dataset to search for trauma
outcome_enrolid <- unique(mdcr_bleed_outcome_2009_2021$ENROLID)

mdcro_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/o", unify_schemas = TRUE) |> 
  select(ENROLID, SVCDATE, DXVER, DX1, DX2, DX3, DX4, PROC1) |> 
  to_duckdb() |> 
  filter(ENROLID %in% outcome_enrolid) |> 
  collect() #96698718 obs

mdcro_2009_2021_bleed2 <- mdcro_2009_2021_bleed |> 
  replace_na(list(DXVER = "9")) |> 
  filter(DXVER != "") |> #removes blanks that probably indicate ambulance services (at this did for 4082398001)
  mutate(DXVER = as.numeric(DXVER)) |> 
  mutate(trauma_code = if_else(
      DXVER == 9,
      if_any(DX1:DX4, ~str_detect(.x, {{trauma_check_icd9}})) |
        if_any(PROC1, ~str_detect(.x, {{trauma_hcpcs_all}})), 
      if_else(
        DXVER == 0,
        if_any(DX1:DX4, ~str_detect(.x, {{trauma_check_icd10}})) |
          if_any(PROC1, ~str_detect(.x, {{trauma_hcpcs_all}})),
        NA
      )
    )
  )

# Outpatient trauma codes
mdcr_outpatient_trauma <- mdcro_2009_2021_bleed2 |> 
  select(ENROLID, SVCDATE, DXVER, trauma_code) |> 
  filter(trauma_code == TRUE) |> 
  mutate(ADMDATE = SVCDATE, source = "outpatient") |> 
  select(-SVCDATE)

# Combine trauma codes
mdcr_all_trauma_codes <- bind_rows(mdcr_inpatient_trauma, mdcr_outpatient_trauma) |> 
  distinct() |> 
  arrange(ENROLID, ADMDATE)


#Join trauma codes with main dataset
mdcr_bleed_outcome_merged <- mdcr_bleed_outcome_2009_2021 |> 
  left_join(mdcr_all_trauma_codes, by = "ENROLID") |> 
   mutate(
    within_window = (ADMDATE.x - 1 <= ADMDATE.y & ADMDATE.y <= ADMDATE.x + 1)
  ) |> 
  filter(within_window) |> 
  distinct(ENROLID, ADMDATE.x) |> 
  mutate(exclusion_event = 1)

mdcr_bleed_outcome_no_trauma <- mdcr_bleed_outcome_2009_2021 |> 
  left_join(mdcr_bleed_outcome_merged, by = c("ENROLID", "ADMDATE" = "ADMDATE.x")) |> 
  filter(bleed_code == TRUE) |> 
  filter(is.na(exclusion_event)) #38587


#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
mdcr_bleed_outcome_no_trauma |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcr_bleed_outcome_no_trauma.parquet")

#Open dataset
mdcr_bleed_outcome_no_trauma <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcr_bleed_outcome_no_trauma.parquet")

#Merge inpatient files
all_outcome <- bind_rows(ccae_bleed_outcome_no_trauma, mdcr_bleed_outcome_no_trauma) |> 
  arrange(ENROLID, ADMDATE) |> 
  group_by(ENROLID) |> 
  mutate(hospnum = row_number()) |> 
  ungroup() |> 
  mutate(eventnum= row_number()) |> 
  select(c(ENROLID, ADMDATE, DAYS, DISDATE, hospnum, eventnum)) #1297106 obs; 1579503 post adjustment; 570608 post second adjustment


all_outcome |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/all_inpatient_bleed_no_trauma.parquet")

all_inpatient_bleed_no_trauma <-  read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/all_inpatient_bleed_no_trauma.parquet")

#Create vector that includes ENROLID of all individuals who experienced outcome in 2009-2021
outcome_vec <- all_inpatient_bleed_no_trauma$ENROLID #1297106

#Shouldn't this be distinct obs? 
all_outcome2 <- all_inpatient_bleed_no_trauma |> 
  distinct(ENROLID)

outcome_vec <- all_outcome2$ENROLID #414293 old; 499926 - pretty decent jump actually; 497398 after adding outpt trauma

```

## Drug

```{r}
#| label: Drug Data
#| echo: false


#Create cohort of patients who had event in either ccae or mdcr and also filled a statin.
ccaed_2009_2021 <- open_dataset(("//pharm-psop/Truven Data/Truven Data R/ccae/d")) |> 
  to_duckdb() |> 
  select(c(ENROLID, NDCNUM, SVCDATE, YEAR, AGE, SEX, DAYSUPP))|>
  filter(ENROLID %in% outcome_vec) |> 
  distinct() |> 
  collect() |> 
  left_join(redbook, by = "NDCNUM") |>  
  mutate(dataset = "ccae") |> 
  select(c(ENROLID, NDCNUM, SVCDATE, YEAR, AGE, SEX, DAYSUPP, THRDTDS, GENNME, MASTFRM, dataset))   #32087676 observations 

#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
ccaed_2009_2021 |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ccaed_2009_2021.parquet")

#Open dataset
ccaed_2009_2021 <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ccaed_2009_2021.parquet")
  
#Repeat for MDCR Cohort & merge with ccaed
mdcrd_2009_2021 <- open_dataset(("//pharm-psop/Truven Data/Truven Data R/mdcr/d")) |> 
  to_duckdb() |> 
  select(c(ENROLID, NDCNUM, SVCDATE, YEAR, AGE, SEX, DAYSUPP))|>
  filter(ENROLID %in% outcome_vec) |> 
  distinct() |> 
  collect () |> 
  left_join(redbook, by = "NDCNUM") |> 
  mutate(dataset = "mdcr") |> 
  select(c(ENROLID, NDCNUM, SVCDATE, YEAR, AGE, SEX, DAYSUPP, THRDTDS, GENNME, MASTFRM, dataset)) #45251032

#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
mdcrd_2009_2021 |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcrd_2009_2021.parquet")

#Open dataset
mdcrd_2009_2021 <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcrd_2009_2021.parquet")
  


#Bind drug files
all_drug <- rbind(ccaed_2009_2021, mdcrd_2009_2021) #77338708



#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
all_drug |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/all_drug_2009_2021.parquet")

#Open dataset
all_drug_2009_2021 <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/all_drug_2009_2021.parquet")



```

# Object Drug Cohort ID

## Object Index

```{r}
##Flag Object drugs and assign index date
obj1 <- all_drug_2009_2021 |> 
  arrange(ENROLID, SVCDATE) |>
  filter(!is.na(AGE)) |> #77,338,708
  mutate(doac = if_any(GENNME,~ str_detect(.x, paste(object, collapse = "|")))) |> 
  filter(doac ==TRUE) |> #509,561
  #filter(DAYSUPP>0) |> #478,301 filters out potentially errant fills - re-review with below?
  group_by(ENROLID) |> 
  mutate(index_date = min(SVCDATE)) |> 
  filter(index_date >= new_user_req) |> #509561 (made 1 year pre-index req - no change bc DOAC first appr 2010)
  ungroup() |> 
  mutate(GENNME = if_else(GENNME == "Rivaroxaban;Rivaroxaban", "Rivaroxaban", GENNME)) |> #Creates uniform naming
  mutate(index_med = if_else(index_date == SVCDATE, GENNME, NA)) |> #create var for index med
  group_by(ENROLID) |> 
  fill(index_med, .direction = "down") |> #fill down for rest of obs
  ungroup() |> 
  mutate(doac_switch = if_else(GENNME == index_med, "match", "switch")) 

##Lots of fills with DS #1 can use NDC to understand package size
#Should use web to identify NDC or FDA website and then search within redbook - no difference
#Maybe wait till have cohort and look at oddities before cutting out

# obj1 |> 
#   filter(GENNME == "Apixaban") |> 
#   group_by(DAYSUPP) |> 
#   count(DAYSUPP)

#create marker for DOAC switch
# Assuming test is your dataset
# Convert SVCDATE to Date type if it is not already


# Create a flag column for claims with negative days' supply
test <- obj1 %>%
  mutate(negative_days_flag = ifelse(DAYSUPP < 0, TRUE, FALSE),
         cancel_flag = FALSE,
         days_to_closest_positive_claim = NA)

test |> 
  filter(ENROLID == 316703)

# Identify pairs of positive and negative claims
for (i in 1:nrow(test)) {
  if (test$negative_days_flag[i]) {
    # Get the current enrollee ID and service date for the negative claim
    enrolid <- test$ENROLID[i]
    svcdate <- test$SVCDATE[i]
    daysupp_negative <- test$DAYSUPP[i]
    
    # Check for positive claims on the same day or within 15 days prior
    positive_claims_15 <- test %>%
      filter(ENROLID == enrolid,
             SVCDATE <= svcdate,
             SVCDATE >= (svcdate - days(15)),
             DAYSUPP > 0)
    
    # Check for exact match positive claims within 45 days prior
    exact_match_45 <- test %>%
      filter(ENROLID == enrolid,
             SVCDATE <= svcdate,
             SVCDATE >= (svcdate - days(60)),
             DAYSUPP == abs(daysupp_negative))
    
    # If there are positive claims within 15 days, find the closest one
    if (nrow(positive_claims_15) > 0) {
      closest_positive_claim <- positive_claims_15 %>%
        arrange(desc(SVCDATE)) %>%
        slice(1)
      
      days_diff <- as.numeric(difftime(svcdate, closest_positive_claim$SVCDATE, units = "days"))
      test$days_to_closest_positive_claim[i] <- days_diff
      
      # Set the cancel flag for both the negative and positive claims
      test$cancel_flag[i] <- TRUE
      test$cancel_flag[which(test$ENROLID == enrolid & 
                             test$SVCDATE == closest_positive_claim$SVCDATE & 
                             test$DAYSUPP == closest_positive_claim$DAYSUPP)] <- TRUE
    }
    
    # If there are exact match positive claims within 45 days, find the closest one
    if (nrow(exact_match_45) > 0) {
      closest_positive_claim <- exact_match_45 %>%
        arrange(desc(SVCDATE)) %>%
        slice(1)
      
      # Set the cancel flag for both the negative and positive claims
      test$cancel_flag[i] <- TRUE
      test$cancel_flag[which(test$ENROLID == enrolid & 
                             test$SVCDATE == closest_positive_claim$SVCDATE & 
                             test$DAYSUPP == closest_positive_claim$DAYSUPP)] <- TRUE
    }
  }
}

# Remove cancelled claims
test_uncancelled <- test %>%
  filter(!cancel_flag & !negative_days_flag)

# df_no_match <- test %>%
#   filter(negative_days_flag & !cancel_flag)

#Select max value if multiple fills on same day. 

test_multfill <- test_uncancelled %>%
  group_by(ENROLID, SVCDATE) %>%
  mutate(fill_count = n()) %>%
  ungroup() %>%
  mutate(multiple_fills_flag = ifelse(fill_count > 1, TRUE, FALSE)) %>%
  filter(!(multiple_fills_flag & DAYSUPP != max(DAYSUPP, na.rm = TRUE))) %>%
  select(-fill_count, -multiple_fills_flag)
  
test_min_index <- test_multfill%>%
  arrange(ENROLID, SVCDATE, DAYSUPP) |> 
  group_by(ENROLID) %>%
  mutate(first_fill_date = min(SVCDATE)) %>%
  ungroup() |> 
  mutate(init_ds_low = if_else(SVCDATE == first_fill_date & DAYSUPP <7, "remove", NA)) |> 
  group_by(ENROLID) |> 
  fill(init_ds_low, .direction = "down") |> 
  ungroup() |> 
  filter(is.na(init_ds_low))

testy <- test_min_index |> 
 group_by(ENROLID) |>
  mutate(first_switch_date = min(SVCDATE[doac_switch == "switch"], na.rm = TRUE)) |>
  ungroup() |>
  filter(is.na(first_switch_date) | SVCDATE < first_switch_date)


##Apply continuous exposure rules
obj2 <- testy |> 
  mutate(obj_fill_end = SVCDATE + DAYSUPP + (DAYSUPP *0.2)) |>  #7d grace (Zhou 2020); modifying to 80* DS
  group_by(ENROLID) |> 
  mutate(obj_end_lagged = lag(obj_fill_end)) |> 
  ungroup() |> 
  #Flag if next fill falls outside grace period
  mutate(cont_expo1 = ifelse(SVCDATE <= obj_end_lagged, "Continuous", "New" )) |> 
  #Change first fill values (currently NA) to "New"
  mutate(cont_expo2 = ifelse(is.na(cont_expo1), "New", cont_expo1)) |> 
  #Filter if "New", "New". Should only occur if new start that isnt first fill
  mutate(censor = ifelse(cont_expo1=="New" & cont_expo2 == "New", 1, NA)) |> 
  group_by(ENROLID) |> 
  fill(censor)  |>  #Fills down the censored variables for filtering; 243201
  ungroup() |> 
  filter(is.na(censor)) #148709

##Create cohort of doac users
obj3 <- obj2 |> 
  group_by(ENROLID) |> 
  mutate(obj_period_end = max(obj_fill_end)) |> 
  ungroup() |> 
  select(ENROLID, GENNME, AGE, SEX, index_date, obj_period_end) |> 
  distinct(ENROLID, .keep_all = TRUE) #41993

obj3 |> 
 mutate(test = obj_period_end - index_date) |> 
  arrange(desc(test))

#Open dataset
all_drug_2009_2021 <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/all_drug_2009_2021.parquet")



```

## Continuous enrollment


```{r}
#Write parquet file for patients 18+ iwth index date and ENROLID for CE assessment
obj3 |>
  filter(AGE>=18) |>  #41975
  select(ENROLID, index_date) |> 
  select(ENROLID, index_date) |> 
  write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ids_with_indexdate.parquet")

#Open dataset
cohort_ids_for_CE <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/ids_with_indexdate.parquet")

cont_enrollment_ids <- cohort_ids_for_CE$ENROLID

#Open relevant T files for CE scanning
ccae_enrol <- open_dataset("//pharm-psop/Truven Data/Truven Data R/ccae/t") |> 
  select(ENROLID, DTSTART, DTEND) |> 
  to_duckdb() |> 
  filter(ENROLID %in% cont_enrollment_ids) |> 
  collect()

mdcr_enrol <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/t") |> 
  select(ENROLID, DTSTART, DTEND) |> 
  to_duckdb() |> 
  filter(ENROLID %in% cont_enrollment_ids) |> 
  collect()

all_enrol <- rbind(ccae_enrol, mdcr_enrol) 

#Set look-back
months_prior <- 12
continuous_enrollment <- evaluate_continuous_enrollment(all_enrol, cohort_ids_for_CE, months_prior)

ids_with_indexdate_ce <- continuous_enrollment |> 
  filter(is_continuously_enrolled == TRUE)

#Create vector of ENROLID meeting criteria
ids_with_ce <- ids_with_indexdate_ce$ENROLID #36842


```


# Study-specific criteria

```{r}

#Filter out patients who do not meet cont_enroll_req criteria
obj4 <- obj3 |>  
  filter(ENROLID %in% ids_with_ce)

##Left join object data to outcome data to duplicate person for each hosp (e.g., 1 pt w/ 3 hosp who filled 5 meds = 15 obs)
obj5 <- left_join(obj4, all_inpatient_bleed_no_trauma, by = "ENROLID") |> #84,688 obs
  arrange(ENROLID, hospnum, ADMDATE) |> 
  mutate(day_obs_start = 0) |> 
  mutate(day_obs_end = obj_period_end - index_date) |> 
  mutate(day_of_event = ADMDATE - index_date) |> 
  mutate(event_occur_outside_obs = ADMDATE<index_date | ADMDATE >obj_period_end) |> 
  filter(event_occur_outside_obs==FALSE) |>  #17103 (all doac)
  filter(GENNME == "Apixaban") |> 
  mutate(object = GENNME) |> 
  select(c(-GENNME, -event_occur_outside_obs)) #7342 apix

ids_for_loop <- unique(obj5$ENROLID)

dataset_for_loop <- obj5 |> 
  arrange(ENROLID, ADMDATE) |> 
  distinct(ENROLID, .keep_all = TRUE) |> 
  select(ENROLID, index_date, obj_period_end, day_obs_start, day_obs_end, object)

dataset_for_loop_outcome <- obj5 |> 
  arrange(ENROLID, ADMDATE) |> 
  select(ENROLID, day_of_event) |> 
  distinct() |> #10 duplicates (i.e., multiple events same day)
  group_by(ENROLID) %>%
  mutate(event_number = row_number()) %>%
  ungroup() |> 
  pivot_wider(
    id_cols = ENROLID, 
    names_from = event_number, 
    values_from = day_of_event,
    names_prefix = "event_"
  )
```

#Precipitant List Generation

```{r}
#Create a list of precipitant drugs that are filled during the object window for each person

obj6 <- obj5 |> 
  distinct(ENROLID, .keep_all = TRUE) |>  #8,624 obs 6,350 (new) maybe this is carryover data from statin?
  select(ENROLID, index_date, obj_period_end)

#Create flag for drugs filled in object window, select distinct drugs, count fills for each, remove statins 
precip_drug_list <- left_join(obj6, all_drug_2009_2021, by = "ENROLID") |> #1935343
  arrange(ENROLID, SVCDATE) |> 
  mutate(precip_flag1 = if_else(SVCDATE > obj_period_end, 1, 0 )) |> 
  filter(precip_flag1 == 0) |> 
  select(-precip_flag1) |> 
  mutate(precip_start = SVCDATE) |> 
  mutate(precip_end = SVCDATE + DAYSUPP) |> 
  mutate(
    concom = ifelse(
      (precip_start <= obj_period_end & precip_end >= index_date), 1, 0
    )) |> 
  filter(concom ==1) |> 
  mutate(doac = if_any(GENNME,~ str_detect(.x, paste(object, collapse = "|")))) |> 
  filter(doac ==FALSE) |> 
  select(-doac) |> 
  group_by(GENNME) |> 
  mutate(count = n()) |> 
  ungroup() |> 
  distinct(GENNME, .keep_all = TRUE) |> #1279 drugs; 1070 apixaban
  filter(count>=30) |> #Remove drugs filled less than 10 times
  select(NDCNUM, GENNME, MASTFRM, THRDTDS) #787 drugs; 452 apixaban


# Exclusion lists
excluded_mastfrm <- c("DEV", "CRE", "OIN", "LOT", "GEL", "EMU", "WAX", "TIN", "EMO", "FOA", "PAD", "PAS")
excluded_thrdtds <- c("Bulk Compounding Ingredient", "Vitamins, Prenatal, Misc Preps", 
                      "Vitamins W/Iron, Misc Preps.", "Vitamins W/Minerals, Misc Prep", 
                      "Vitamins, Plain, Misc Preps.", "Vitamins, Prenatal")

# Filter and arrange the drug list data
precipitants <- precip_drug_list %>%
  arrange(GENNME) %>%
  filter(!MASTFRM %in% excluded_mastfrm) %>%
  filter(!THRDTDS %in% excluded_thrdtds) %>%
  separate(GENNME, into = paste0("col", 1:10), sep = "/", fill = "right") %>% #Parse where "/" separates names. Assumes wont split into more than 10 columns
  select(starts_with("col")) #714 drugs - Let's keep split and then evaluate each separately

# Convert data from wide to long format, smush, remove duplicates
precip_long <- precipitants %>%
  gather() %>%
  filter(!is.na(value)) |> 
  distinct()
  
# Split values using semicolon, assuming no more than 10 columns
precip_split2 <- precip_long %>%
  separate(value, into = paste0("col", 1:10), sep = ";", fill = "right") |> 
  select(starts_with("col"))

# Convert data to long format, filter duplicates, and extract unique values into a vector
precipitant_full <- precip_split2 %>%
  gather() %>%
  filter(!is.na(value)) |> 
  distinct(value) |> 
  pull() #515; 401 apixaban

#Could do split and combo and just see what the difference is? 
```

# Precipitant loop

```{r}

#Schedule time with Todd to go through if it's working

#| warning: false
#| message: false

#First create empty tibbles for results tables
results_table <- tibble()
results_table2 <- tibble()
results_table3 <- tibble()

precip1 <- all_drug_2009_2021 |> 
  arrange(ENROLID, SVCDATE) |>
  filter(!is.na(AGE)) |> 
  filter(ENROLID %in% ids_for_loop) |> 
  mutate(pre_fill_end = SVCDATE + DAYSUPP + (DAYSUPP *0.2)) |>  
  rename(expo_start_date = SVCDATE) |> 
  rename(expo_end_date = pre_fill_end) |> 
  rename(precipitant=GENNME)


# Initialize the progress bar
pb <- progress_bar$new(
  total = length(precipitant_full),
  format = "  [:bar] :current/:total (:percent) in :elapsed eta: :eta"
)

#Evaluate levothyroxine - PROBABLY USE THIS IF YOU CAN. I THINK BETTA. Need to work in loop for meds
#I think can make precipitant drug fills more "concise" by establishing the windows of exposure early and
#then build the function to just pick one and evaluate
#The rowwise below is super slow; try to make more efficient. 


precip2 <- precip1 |> 
  select(ENROLID, precipitant, expo_start_date, expo_end_date) |> 
  left_join(dataset_for_loop, by = "ENROLID") |> 
  select(ENROLID, object, day_obs_start, day_obs_end, index_date, obj_period_end, precipitant, expo_start_date, expo_end_date) |> 
  mutate(day_exposure_start = as.numeric(expo_start_date - index_date)) |> 
  filter(day_exposure_start <= day_obs_end) |> 
  mutate(day_exposure_end = as.numeric(expo_end_date - index_date)) |> 
  filter(day_exposure_end >= 0)

# Function to merge overlapping intervals
merge_intervals <- function(data) {
  data <- data[order(data$day_exposure_start), ]
  merged <- data[1, , drop = FALSE]
  for (i in 2:nrow(data)) {
    if (is.na(data$day_exposure_start[i]) || is.na(data$day_exposure_end[i])) {
      next
    }
    if (data$day_exposure_start[i] <= merged$day_exposure_end[nrow(merged)] + 1) {
      merged$day_exposure_end[nrow(merged)] <- max(merged$day_exposure_end[nrow(merged)], data$day_exposure_end[i], na.rm = TRUE)
    } else {
      merged <- rbind(merged, data[i, , drop = FALSE])
    }
  }
  return(merged)
}

# Apply the function to each ENROLID precipitant group
collapsed_df <- precip2 %>%
  mutate(day_obs_end = as.numeric(day_obs_end)) |> 
  group_by(ENROLID, precipitant) %>%
  do(merge_intervals(.)) %>%
  ungroup() |> 
  select(ENROLID, precipitant, object, day_obs_start, day_obs_end,day_exposure_start, day_exposure_end) |>
  mutate(risk_window_start = if_else(day_obs_start >= day_exposure_start, day_obs_start, day_exposure_start)) |>
  mutate(risk_window_end = if_else(day_obs_end <= day_exposure_end, day_obs_end, day_exposure_end)) 

##Now, using this data, need to generate complete windows so unexposed periods are present. 


# Generate complete windows
generate_windows <- function(data) {
  max_obs_end <- max(data$day_obs_end)
  windows <- data.frame()
  
  for (i in 1:nrow(data)) {
    if (i == 1 && data$risk_window_start[i] > 0) {
      windows <- rbind(windows, data.frame(
        ENROLID = data$ENROLID[i],
        window_start = 0,
        window_end = data$risk_window_start[i] - 1,
        exposure = "Unexposed"
      ))
    }
    
    windows <- rbind(windows, data.frame(
      ENROLID = data$ENROLID[i],
      window_start = data$risk_window_start[i],
      window_end = data$risk_window_end[i],
      exposure = "Exposed"
    ))
    
    if (i < nrow(data) && data$risk_window_end[i] < data$risk_window_start[i + 1] - 1) {
      windows <- rbind(windows, data.frame(
        ENROLID = data$ENROLID[i],
        window_start = data$risk_window_end[i] + 1,
        window_end = data$risk_window_start[i + 1] - 1,
        exposure = "Unexposed"
      ))
    }
  }
  
  if (data$risk_window_end[nrow(data)] < max_obs_end) {
    windows <- rbind(windows, data.frame(
      ENROLID = data$ENROLID[nrow(data)],
      window_start = data$risk_window_end[nrow(data)] + 1,
      window_end = max_obs_end,
      exposure = "Unexposed"
    ))
  }
  
  return(windows)
}

# Apply the function to generate windows
windows_df <- collapsed_df %>%
  group_by(ENROLID, precipitant) %>%
  do(generate_windows(.)) %>%
  ungroup()

 
# windows_df |> 
#   filter(precipitant == "Azithromycin") |> 
#   mutate(time = window_end - window_start) |> 
#   group_by(exposure) |> 
#   summarise(total_time = sum(time, na.rm = TRUE))

##I think the loop needs to start here.
precip3 <- precip2 |> 
  select(ENROLID, object, precipitant) |> 
  distinct() |> 
  left_join(windows_df, by = c("ENROLID", "precipitant")) |> 
  #filter(precipitant == "Levothyroxine Sodium") |> 
  mutate(exposure = if_else(exposure == "Exposed", 1, 0))

precip4 <- precip3 |> 
  left_join(dataset_for_loop_outcome, by = "ENROLID") |> 
  rowwise() %>%
  mutate(event_indicator = if_else(any(c_across(starts_with("event_")) >= window_start & c_across(starts_with("event_")) <= window_end), 1, 0)) %>%
  ungroup() |> 
  mutate(event_indicator = replace_na(event_indicator, 0)) |> 
  select(ENROLID, object, precipitant, window_start, window_end, exposure, event_indicator) |> 
  mutate(time_at_risk = window_end - window_start + 1) %>%
  mutate(offset_term = log(time_at_risk))

#Let's run it!
model <- clogit(event_indicator ~ exposure + offset(offset_term) + strata(ENROLID), data = precip4)
summary(model)


###REVISED LOOP#####
library(profvis)
library(rstanarm)

# Initialize the results tables
results_table <- data.frame()
results_table2 <- data.frame()

for (i in precipitant_full) {
  tryCatch({
    # Update the progress bar (if you have one)
    pb$tick()
 # Combine with original data
    precip3 <- precip2 |> 
      select(ENROLID, object, precipitant) |> 
      distinct() |> 
      left_join(windows_df, by = c("ENROLID", "precipitant")) |> 
      filter(precipitant == i) |>  # Filter for the current precipitant
      mutate(exposure = if_else(exposure == "Exposed", 1, 0))

    precip4 <- precip3 |> 
      left_join(dataset_for_loop_outcome, by = "ENROLID") |> 
      rowwise() %>%
      mutate(event_indicator = if_else(any(c_across(starts_with("event_")) >= window_start & c_across(starts_with("event_")) <= window_end), 1, 0)) %>%
      ungroup() |> 
      mutate(event_indicator = replace_na(event_indicator, 0)) |> 
      select(ENROLID, object, precipitant, window_start, window_end, exposure, event_indicator) |> 
      mutate(time_at_risk = window_end - window_start + 1) %>%
      mutate(offset_term = log(time_at_risk))

    # Fit the Cox model - use this. stan_glmer doesn't work
    # model <- clogit(event_indicator ~ exposure + offset(offset_term) + strata(ENROLID), data = precip4)
    # summary_model <- summary(model)
   
     # Fit the Bayesian mixed-effects model
    model <- stan_glmer(event_indicator ~ exposure + offset(offset_term) + (1 | ENROLID), data = precip4, family = binomial(), prior = normal(0, 1), chains = 4, iter = 2000)

    # Extract posterior estimates
    summary_model <- summary(model)

    # Extract coefficients and confidence intervals
    coef_df <- as.data.frame(summary_model$coefficients) %>% janitor::clean_names() %>% mutate(drug = i)
    confint_df <- as.data.frame(summary_model$conf.int) %>% janitor::clean_names() %>% mutate(drug = i)



    #   
    # # Extract coefficients and confidence intervals
    # coef_df <- summary_model$coefficients |> as.data.frame() |> janitor::clean_names() |> mutate(drug = i)
    # confint_df <- summary_model$conf.int |> as.data.frame() |> janitor::clean_names() |> mutate(drug = i)

    # Append to results tables
    results_table <- bind_rows(results_table, confint_df)
    results_table2 <- bind_rows(results_table2, coef_df)

  }, error=function(e) {
    cat("ERROR :", conditionMessage(e), "\n")
  })
}

# Combine results tables and adjust p-values
# results_table3 <- bind_cols(results_table, results_table2$pr_z, results_table2$se_coef) |> janitor::clean_names()

results_table3 <- bind_cols(results_table, results_table2[, c("pr_z", "se_coef")]) %>% janitor::clean_names()

adjusted_pval <- p.adjust(results_table3$x6, method = "fdr") |> as.data.frame() |> janitor::clean_names()

results_table4 <- bind_cols(results_table3, adjusted_pval) |> 
  rename(adjusted_pval = p_adjust_results_table3_x6_method_fdr) |> 
  rename(p_value = x6) |> 
  rename(se = x7) |> 
  arrange(adjusted_pval)

  # Assuming `precipitant_full` is a vector of all precipitant names
  precipitant_full <- unique(precipitant_full)
  pb <- progress_bar$new(
    format = "[:bar] :current/:total (:percent) :elapsed",
    total = length(precipitant_full),
    clear = FALSE
  )

#precipitant_full <- "Levothyroxine Sodium"
#Loop in drugs in precipitant list
tic() #33 min
for (i in precipitant_full) {
tryCatch({
  # Update the progress bar
    pb$tick()

#Create Precipitant Data Set  
precip2<- precip1 |> 
  select(ENROLID, precipitant, expo_start_date, expo_end_date) |> 
  mutate(precip = if_any(precipitant,~ str_detect(.x, i))) |> 
  filter(precip==TRUE) |> 
  left_join(obj5, precip2, by = "ENROLID") |> 
  select(ENROLID, day_obs_start, day_obs_end, day_of_event, expo_start_date, expo_end_date, hospnum, index_date) |>
  mutate(aexpo=expo_start_date-index_date) |> 
  filter(aexpo<=day_obs_end) |> 
  mutate(aendexpo=expo_end_date - index_date) |> 
  filter(aendexpo>=0) |> 
  mutate(event_exp=ifelse(day_of_event>=aexpo & day_of_event<=aendexpo, 1, 0)) |> 
  mutate(day_obs_start=as.integer(day_obs_start)) |> 
  distinct() 

regression <- standardsccs(day_of_event~aexpo, indiv=ENROLID, astart=day_obs_start, aend=day_obs_end, aevent=day_of_event, adrug=aexpo, aedrug=aendexpo, dataformat="stack", data=precip2)
regression

# #Test
# testdata <- formatdata(indiv=ENROLID, astart=astart, aend=aend,  aevent=aevent, adrug=aexpo, aedrug=aendexpo, data=analytic_dataset_ccae)
# 
# fit <- coxph(formula = Surv(rep(1, 2436L), event) ~ aexpo + strata(indiv) +
#     offset(log(interval)), data = testdata, method = "exact")
# summary(fit)

# testdata$indiv <-as.factor(testdata$indiv)
# gnm(event~aexpo, eliminate = indiv, family = "poisson", data = testdata)


cox_output <- regression$conf.int |> as.data.frame() |> janitor::clean_names() |> 
  mutate(drug = i)

results_table <- bind_rows(results_table, cox_output)

coefficients <- regression$coefficients |> as.data.frame() |> janitor::clean_names() |> 
  mutate(drug = i)

results_table2 <- bind_rows(results_table2, coefficients)

 }, error=function(e){cat("ERROR :",conditionMessage(e), "/n")})
}

results_table3 <- bind_cols(results_table, results_table2$pr_z, results_table2$se_coef) |> janitor::clean_names()

adjusted_pval <- p.adjust(results_table3$x6, method = "fdr") |> as.data.frame() |> janitor::clean_names()

results_table4 <- bind_cols(results_table3, adjusted_pval) |> 
  rename(adjusted_pval = p_adjust_results_table3_x6_method_fdr) |> 
  rename(p_value = x6) |> 
  rename(se = x7) |> 
  arrange(adjusted_pval)
toc() #150s (6 drugs); 5928s (385 drugs)

write.csv(results_table4, "output2.csv", row.names = FALSE)
write.xlsx(results_table4, "output2.xlsx", row.names = FALSE)


# results_table2 <- results_table2 |> 
#   filter(exp_coef<=10 | exp_coef>=-10)


 


#Would it be correct to remove infinite estimates? or NA?
#How can I remove drugs that arent in the pair? I would need to generate the list at a different time I think
#I could use precip1 I think
#keep in mind limitation of unk if combo meds have synergystic effects (2 interacting meds in 1)

# adjusted <- p.adjust(results_table2$pr_z, method = "fdr")
# adjusted

# results_table4 <- results_table |>
#   clean_names() |>
#   relocate(drug, .before = exp_coef) |>
#   filter(lower_95 != 0) |>
#   filter(upper_95 !=1) |>
#   mutate(flag = ifelse(lower_95>=1 & exp_coef >=lower_95, 1, 0))
# # 
# fdr_eval <- results_table2 |>
#   p.adjust(pr_z, method = "fdr") 
# 
# test <- p.adjust(results_table2$pr_z, method = "fdr") |> as.data.frame() |> clean_names()
# 



#Should I be filtering AEXPO > AEND???? Probably...
```

#Experiment Chunk

```{r}

# analytic_dataset_ccae3 <- analytic_dataset_ccae |> 
#   select(indiv, astart, aend, aevent, aexpo, aendexpo) |> 
#   mutate_at(c('indiv', 'astart', 'aend', 'aevent', 'aexpo', 'aendexpo'), as.numeric)
# 
# par(mfrow=c(1,2), mar=c(4.1,4.1,1,1), cex.lab=1.4)  
# usta <- analytic_dataset_ccae3$astart[duplicated(analytic_dataset_ccae3$indiv)==0]  
# uend <- analytic_dataset_ccae3$aend[duplicated(analytic_dataset_ccae3$indiv)==0]  
# os <- order(usta)  
# plot(c(min(usta)/365.25,max(uend)/365.25), c(1,length(os)),  type="n", xlab="age (years)", ylab="case rank")  
# segments(usta[os]/365.25, 1:length(os), uend[os]/365.25,  1:length(os))  
# os2 <- order(analytic_dataset_ccae3$aexpo)  
# plot(c(min(analytic_dataset_ccae3$aexpo)/365.25, max(analytic_dataset_ccae3$aendexpo)/365.25), c(1,  length(os2)), type="n", xlab="age (years)", ylab=  "exposure rank")  
# segments(analytic_dataset_ccae3$aexpo[os2]/365.25, 1:length(os2),  analytic_dataset_ccae3$aendexpo[os2]/365.25, 1:length(os2))  
# 
# 
# 
# require(survival)
# test <- clogit(event ~ expgrp + strata(indiv) + offset(loginterval), data = analytic_dataset_ccae2)
# summary(test)
```

# Forest Plot

```{r}

# Define Theme
tm <- forest_theme(
  base_size = 10,
  ci_pch = 15,  # Confidence interval point shape
  ci_col = "#762a83",  # Confidence interval line color
  ci_fill = "black",  # Confidence interval fill color
  ci_alpha = 1,  # Confidence interval transparency
  ci_lty = 1,  # Confidence interval line type
  ci_lwd = 1.5,  # Confidence interval line width
  ci_Theight = 0.2,  # Set a "T" end at the end of CI
  refline_lwd = 2,  # Reference line width
  refline_lty = "dashed",  # Reference line type
  refline_col = "grey20",  # Reference line color
  vertline_lwd = 1,  # Vertical line width
  vertline_lty = "dashed",  # Vertical line type
  vertline_col = "grey20",  # Vertical line color
  summary_fill = "#4575b4",  # Change summary color for filling
  summary_col = "#4575b4",  # Change summary color for borders
  footnote_cex = 0.6,  # Footnote font size
  footnote_fontface = "italic",  # Footnote font face
  footnote_col = "blue"  # Footnote color
)

# Process data
forest_data <- results_table4 |> 
  select(-exp_coef_2, -p_value) |> 
  relocate(drug, .before = 1) |> 
  rename(Drug = drug)

forest_data$` ` <- paste(rep(" ", 40), collapse = " ")
forest_data$`  ` <- paste(rep(" ", 2), collapse = " ")

forest_data <- forest_data |> 
  relocate(`  `, .after = 1) |> 
  rename("Adjusted p-value" = adjusted_pval)

forest_data$`HR (95% CI)` <- ifelse(
  is.na(forest_data$upper_95), "", 
  sprintf("%.2f (%.2f to %.2f)", forest_data$exp_coef, forest_data$lower_95, forest_data$upper_95)
)

forest_data <- forest_data |> 
  relocate("Adjusted p-value", .after = last_col()) |> 
  mutate(across("Adjusted p-value", round, 3)) |> 
  arrange(`Adjusted p-value`)

# Create forest plot
p <- forest(
  forest_data |> select(-c(lower_95, upper_95, se, exp_coef)),
  est = forest_data$exp_coef,
  lower = forest_data$lower_95, 
  upper = forest_data$upper_95,
  sizes = forest_data$se,
  ref_line = 1, 
  ci_column = 3,
  arrow_lab = c("Protective", "Hazardous"),
  xlim = c(0, 6),
  footnote = "This is the demo data.", 
  theme = tm
)

# # Display plot
# plot(p)


ggsave("plot.png", plot = p, height = 55, width = 10, dpi = 330, limitsize = FALSE)

```

#Generate Table 1
```{r}
##Create cohort of statin users
tab1a <- obj2 |> 
  group_by(ENROLID) |> 
  mutate(obj_period_end = max(obj_fill_end)) |> 
  ungroup() |> 
  select(ENROLID, GENNME, AGE, SEX, indexdt, dataset, obj_period_end) |> 
  distinct(ENROLID, .keep_all = TRUE) #101,556 unique users (old); 21443 (new)

#Filter out patients who do not meet cont_enroll_req criteria
tab1b <- tab1a |>  
  mutate(ccae = ENROLID %in% ids_with_ce_ccae) |>
  mutate(mdcr = ENROLID %in% ids_with_ce_mdcr) |> 
  filter(ccae == TRUE | mdcr == TRUE) #72,757 obs

##Left join object data to outcome data to duplicate person for each hosp (e.g., 1 pt w/ 3 hosp who filled 5 meds = 15 obs)
tab1c <- left_join(tab1b, all_outcome, by = "ENROLID") |> #84,688 obs
  arrange(ENROLID, hospnum, ADMDATE) |> 
  select(ENROLID, GENNME, SEX, AGE, ADMDATE, indexdt, ADMDATE, DISDATE, obj_period_end, hospnum) |>  
  mutate(astart = 0) |> 
  mutate(aend= obj_period_end - indexdt) |> 
  mutate(aevent = ADMDATE - indexdt) |> 
  mutate(flag2=ADMDATE<indexdt | ADMDATE >obj_period_end) |> 
  filter(flag2==FALSE) |>  #9,106 7,818
  mutate(GENNME = ifelse(GENNME == "Rivaroxaban;Rivaroxaban", "Rivaroxaban", GENNME))

tab1d <- tab1c |> 
  arrange(ENROLID, ADMDATE) |> 
  distinct(ENROLID, .keep_all = TRUE)

tab1d |> 
  group_by(GENNME) |> 
  summary(AGE) 


```



# Recycling Bin

```{r}


#analytic_dataset_ccae$aexpo <- as.numeric(analytic_dataset_ccae$aexpo)
#analytic_dataset_ccae$aevent <- as.numeric(analytic_dataset_ccae$aevent)
#analytic_dataset_ccae$astart <- as.numeric(analytic_dataset_ccae$astart)
#analytic_dataset_ccae$aend <- as.numeric(analytic_dataset_ccae$aend)
#output <- tidy(gnm(aevent ~ aexpo, data=analytic_dataset_ccae, family=poisson,
  #eliminate=factor(indiv)), conf.int = T, exp = T)

#output <- output |> 
  #mutate(drug = i)

#results_table <- bind_rows(results_table, output)




# 
# obj6 <- merge1|> #5215
#   select(ENROLID, AGE, ADMDATE, indexdt, ADMDATE, DISDATE, obj_period_end, PDX, hospnum) |>  
#   mutate(astart = AGE * 365) |> 
#   group_by(ENROLID) |> 
#   mutate(aend= astart + (max(obj_period_end) - indexdt)) |> 
#   ungroup() |> 
#   mutate(aevent = astart + (ADMDATE - indexdt)) |> 
#   mutate(flag2=ADMDATE<indexdt | ADMDATE >obj_period_end) |> 
#   filter(flag2==FALSE)


```

#Experiment Chunk - converting For loop to map

```{r}
tic()
precipitant_function <- function(i) {
  
  tryCatch({
    
  #Create Precipitant Data Set  
  precip2 <- precip1 |> 
    select(ENROLID, exposure, expo_start_date, expo_end_date) |> 
    mutate(precipitant = if_any(exposure,~ str_detect(.x, i))) |> 
    filter(precipitant==TRUE) |> 
    left_join(obj6, precip2, by = "ENROLID") |> 
    select(ENROLID, astart, aend, aevent, expo_start_date, expo_end_date, hospnum, indexdt) |>
    mutate(aexpo=expo_start_date-indexdt) |> 
    filter(aexpo<=aend) |> 
    mutate(aendexpo=expo_end_date-indexdt) |> 
    filter(aendexpo>=0) |> 
    mutate(event_exp=ifelse(aevent>=aexpo & aevent<=aendexpo, 1, 0)) |> 
    mutate(astart=as.integer(astart)) |> 
    distinct() 
    
    regression <- standardsccs(aevent~aexpo, indiv=ENROLID, astart=astart, aend=aend, aevent=aevent, adrug=aexpo, aedrug=aendexpo, dataformat="stack", data=precip2)

    cox_output <- regression$conf.int |> as.data.frame() |> janitor::clean_names()
    cox_output <- cox_output |> mutate(drug = i)

    results_table <<- bind_rows(results_table, cox_output)

    coefficients <- regression$coefficients |> as.data.frame() |> janitor::clean_names()
    coefficients <- coefficients |> mutate(drug = i)

    results_table2 <<- bind_rows(results_table2, coefficients)

 }, error=function(e){cat("ERROR :",conditionMessage(e), "/n")})
}
  
# Use purrr::map() instead of a for loop to process all precipitants
map(precipitant, precipitant_function)
toc()

##Works the same speed map vs. for loop.
```

# Old outcome code
```{r}
#Filter and collect mdcrs cases with transfusion REVCODE 
mdcrs_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/s") |> 
  select(c(ENROLID, YEAR, ADMDATE, DISDATE, REVCODE)) |> 
  to_duckdb() |> 
  filter(REVCODE %in% c("0390", "0391") & !is.na(ENROLID)) |> 
  distinct(ENROLID, .keep_all = TRUE) |> 
  collect() #1304548 obs

#Collect the inpatient (time: 9 minutes for full)
mdcri_2009_2021_bleed <- open_dataset("//pharm-psop/Truven Data/Truven Data R/mdcr/i", unify_schemas = TRUE) |> #24224052 obs
  select(c(ENROLID, YEAR, ADMDATE, AGE, DAYS, DISDATE, DXVER, PDX, DX1:DX15, PROC1:PROC15)) |> 
  to_duckdb() |> 
  collect() 

#Merge mdcri with mdcrs to get REVCODE
mdcri_2009_2021_bleed_merge <- mdcri_2009_2021_bleed |> 
  left_join(mdcrs_2009_2021_bleed, by = c("ENROLID", "YEAR", "ADMDATE", "DISDATE")) |> 
  filter(!is.na(ENROLID)) |>
  replace_na(list(DXVER = "9")) |> 
  filter(DXVER != "") |> #removes blanks that probably indicate ambulance services (at this did for 4082398001)
  mutate(DXVER = as.numeric(DXVER))

#Identify IDs with event in mdcr using criteria outlined by Leonard et al (time: 14 min)
mdcr_bleed_outcome_2009_2021 <- mdcri_2009_2021_bleed_merge |> #24168165 obs
  #filter(YEAR == 2021) |>  #test to make sure working on small dataset
  #filter(ENROLID == 4082398001) |> 
  mutate(
    bleed_code = if_else(
      is.na(DXVER) | DXVER == 9, #think can remove is.na(DXVER but not checking now)
      if_any(PDX, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
        (if_any(PDX, ~str_detect(.x, {{all_gib_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})) |
            !is.na(REVCODE))) | 
      (if_any(PDX, ~str_detect(.x, {{all_unspec_icd9_possible}})) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}})))) |
      (if_any(PDX, ~ gu_icd9_possible %in% .x)  &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_icd9_bleeds_ind}}))) &
         (if_any(DX2:DX15, ~str_detect(.x, {{all_comb_sec}})))),
      if_else(
        DXVER == 0, 
        if_any(PDX, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
          (if_any(PDX, ~str_detect(.x, {{all_gib_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})) |
                !is.na(REVCODE))) | 
          (if_any(PDX, ~str_detect(.x, {{all_unspec_icd10_possible}})) &
             (if_any(DX2:DX15, ~str_detect(.x, {{all_icd10_bleeds_ind}})))),
        NA
      )
    )
  ) |>
  group_by(ENROLID) |> 
  mutate(bleed_ever = as.integer(any(bleed_code))) |> 
  filter(bleed_ever == 1) |> #797760 - now 796266 - maybe old ICD codes were errant?
  ungroup() 


mdcr_bleed_outcome2 <- mdcr_bleed_outcome_2009_2021 |> 
  mutate(
    trauma_code = if_else(
      DXVER == 9,
      if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd9}})) |
        if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})), 
      if_else(
        DXVER == 0,
        if_any(DX1:DX15, ~str_detect(.x, {{trauma_check_icd10}})) |
          if_any(PROC1:PROC15, ~str_detect(.x, {{trauma_hcpcs_all}})),
        NA
      )
    )
  ) #796266


mdcr_bleed_outcome_no_trauma <- mdcr_bleed_outcome2 |> 
  filter(!(trauma_code & bleed_code)) |> #Filters out ind w/ trauma code during bleed hosp - 787434
  group_by(ENROLID) %>%
  filter(!(all(bleed_code == FALSE))) |>  #Filters out ind who only have FALSE bleed codes remaining (bleed only occurred w/ trauma) #773845 (what was this?)
  ungroup() |> 
  arrange(ENROLID, ADMDATE) |> 
  group_by(ENROLID) |> 
  mutate(
    lag_date = lag(DISDATE),
    lead_date = lead(ADMDATE),
    lag_trauma = lag(trauma_code),
    lead_trauma = lead(trauma_code),
    prev_trauma_flag = +(bleed_code & lag_trauma & lag_date >= ADMDATE - 1), #flags ind w/ prev hosp w/ trauma code
    next_trauma_flag = +(bleed_code & lead_trauma & lead_date <= ADMDATE + 1),
    trauma_exclude_flag = +(prev_trauma_flag | next_trauma_flag) # Flag for trauma code day prior, day of, or day after admission
  ) |> 
  filter(trauma_exclude_flag == 0 | is.na(trauma_exclude_flag)) |> # Exclude those individuals
  group_by(ENROLID) |> 
  filter(!(all(bleed_code == FALSE))) |> # Re-filters those who only have false bleed codes now #806985 obs
  ungroup()

#Save dataset so don't have to do that again. Need to re-save in correct folder before uploading to github
mdcr_bleed_outcome_no_trauma |> write_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcr_inpatient_bleed_no_trauma.parquet")

#Open dataset
mdcr_bleed_outcome_no_trauma <- read_parquet("C:/Users/kahanso2/Documents/doac-ddi/data/mdcr_inpatient_bleed_no_trauma.parquet")
```

